# 1장. 타입스크립트 알아보기
타입스크립트란 무엇이고, 타입스크립트를 어떻게 여겨야 하는지, 자바스크립트와는 어떤 관계인지, 타입스크립트의 타입들은 null이 가능한지, any 타입에서는 어떨지, 덕 타이핑이 가능한지등을 알아본다.

타입스크립트는 인터프리터로 실행되는 것도 아니고, 저수준 언어로 컴파일 되는 것도 아니다. 자바스크립트로 컴파일되며, 실행 역시 타입스크립트가 아닌 자바스크립트로 이루어진다.

따라서, 둘의 관계는 필연적이다. 이러한 타입스크립트와 자바스크립트의 관계를 잘 이해한다면 타입스크립트 개발자로서 한 단계 성장할 것이다.

## 🌈 Item1. 타입스크립트와 자바스크립트의 관계 이해하기

“타입스크립트는 자바스크립트의 상위 집합이다” 라는 말이 많다. 이 문장들이 정확히 무슨 의미인지, 타입스크립트와 자바스크립트는 어떤 관계인지 자세히 알아보자. 타입스크립트는 자바스크립트와 굉장히 밀접한 관계에 있기 때문에, 어떻게 연관되어 있는지 제대로 이해하는 것이 중요하다.



자바스크립트는 파일이 .js 확장자를 사용하는 반면, 타입스크립트파일은 .ts 파일을 사용한다. 그렇다고 자바스크립트와 타입스크립트가 다르다는 것을 의미하는 것은 아니고 타입스크립트가 자바스크립트의 슈퍼셋이기 때문에 .js 파일에 있는 코드는 이미 타입스크립트라고 할 수 있다.



이러한 특성은 기존에 존재하는 자바스크립트 코드를 타입스크립트로 마이그레이션 하는데 엄청난 이점이 된다. 모든 자바스크립트 프로그램이 타입스크립트라는 명제는 참이지만, 그 반대는 성립하지 않는다. 즉, 타입스크립트 프로그램이지만 자바스크립트가 아닌 프로그램이 존재하게 된다. 이는 타입스크립트가 타입을 명시하는 추가적인 문법을 가지기 때문이다.



다음의 예를 보자.
```typescript
function greet(who: string) {
    console.log('Hello', who);
}
```

이는 유효한 타입스크립트 프로그램이다.

그러나 자바스크립트를 구동하는 노드 같은 프로그램으로 앞의 코드를 실행하면 오류를 출력한다. 즉, 타입구문을 사용하는 순간부터 자바스크립트가 아닌 타입스크립트의 영역이다.



타입스크립트 컴파일러는 타입스크립트뿐만 아니라 일반 자바스크립트 프로그램에도 유용하다. 다음의 예를 보자.
```
let city = `new york city`;
console.log(city.toUpperCase());
```
이 코드를 자바스크립트 컴파일로서 실행하면 다음과 같은 오류가 발생한다.

`TypeError: city.toUppercase is not a function`

앞의 코드에는 타입 구문이 없지만, 타입스크립트의 타입 체커는 문제점을 찾아 냅니다. city 변수가 문자열이라는 것을 알려주지 않아도 타입스크립트는 초깃값으로부터 타입을 추론한다.

타입시스템의 목표중 하나는 런타임에 오류를 발생시킬 코드를 미리 찾아내는 것이다. 타입스크립트가 ‘정적’타입 시스템이라는 것은 바로 이런 특징을 말한다.

그러나 모든 오류를 찾아내지는 않는다. 오류가 발생하진 않아도 다른 의도로 동작하는 코드도 있다. 

다음의 자바스크립트 프로그램을 보자.
```typescript
const states = [
    {
        name: 'A',
        capital: "seoul"
    },
    {
        name: 'B',
        capital: "Phoenix"
    },
    {
        name: 'C',
        capital: "Tokyo"
    }
]

// undefined
// undefined
// undefined
for(const state of states) {
    console.log(state.capitol);
}
```
앞의 코드는 유효한 자바스크립트이며 어떠한 오류도 없이 실행된다. 그러나 루프 내의 state.capial 은 의도한 코드가 아니다.

이런 경우에 타입스크립트 타입체커는 오류를 제시한다.



타입스크립트는 타입 구문 없이도 오류를 잡을 수 있지만, 타입 구문을 추가한다면 훨씬 더 많은 오류를 찾아낼 수 있다.

물론, 위의 예에서는 어느 쪽이 오타인지 판단하지는 못한다. 따라서 명시적으로 states 를 선언하여 의도를 분명히 해야한다.
```typescript
interface State {
    name: string;
    capital: string;
}
const states: State[] = [
    {
        name: 'A',
        capitol: "seoul"
    },
    {
        name: 'B',
        capital: "Phoenix"
    },
    {
        name: 'C',
        capital: "Tokyo"
    }
]
```


이제 오류가 어디에서 발생했는지 찾을 수 있고, 제시된 해결책도 올바르다. 의도를 명확히 해서 타입스크립트가 잠재적 문제점을 찾을 수 있게 했다.



타입스크립트 타입 시스템은 자바스크립트의 런타임 동작을 ‘모델링’ 한다. 런타임 체크를 엄격하게 하는 언어를 사용해 왔다면 다음 결과들이 꽤 당황스럽게 느껴질 것이다.
```typescript
const x = 2 + '3'; // 정상, string 타입
const y = '2' + 3; // 정상, string 타입
```
이 예제는 다른 언어였다면 런타임 오류가 될 만한 코드이다. 하지만 타입스크립트의 타입 체커는 정상으로 인식한다. 두 줄 모두 ‘23’으로 출력된다.

반대로 정상 동작하는 코드에 오류를 표시하기도 한다. 다음은 런타임 오류가 발생하지 않는 코드인데, 타입 체커는 문제점을 표시한다.
```typescript
const a = null + 7; // 자바스크립트에는 a값이 7
const b = [] + 12; // 자바스크립트에는 b의 값이 12
alert('Hello', 'TypeScript'); // "Hello" 경고를 표시
```
자바스크립트의 런타임 동작을 모델링하는 것은 타입스크립트 타입 시스템의 기본 원칙이다. 물론, 프로그램에서 오류가 발생하지 않더라도 타입체커가 오류를 표시할 때도 있다.



언제 자바스크립트 런타임 동작을 그대로 모델링할지, 또는 추가적인 타입을 체크를 할 지 분명하지 않다면 타입스크립트를 왜 사용하는지 의문이 들 수 있다. 순전히 사용자의 몫이며, 위의 오류처럼  null + 7 이 7을 출력한다는 것이 익숙하다면 사용하지 않아도 된다.